import numpy as np
import cv2

def region_of_interest(img, vertices):
    mask = np.zeros_like(img)
    cv2.fillPoly(mask, vertices, 255)
    return cv2.bitwise_and(img, mask)

def draw_lines(img, lines, color=(255, 0, 0), thickness=3):
    if lines is None:
        return
    for line in lines:
        for x1, y1, x2, y2 in line:
            cv2.line(img, (x1, y1), (x2, y2), color, thickness)

def get_center(box):
    x1, y1, x2, y2 = box
    return ((x1 + x2) // 2, (y1 + y2) // 2)

def estimate_distance(bbox, focal_length, car_length):
    pixel_length = bbox[2] - bbox[0]
    if pixel_length <= 0:
        return float('inf')
    return (car_length * focal_length) / pixel_length

def draw_boxes(frame, boxes):
    for box in boxes:
        if len(box) == 2:
            (x1, y1, x2, y2), color = box
            cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), color, 2)
        elif len(box) == 3:
            (x1, y1, x2, y2), color, text = box
            cv2.rectangle(frame, (int(x1), int(y1)), (int(x2), int(y2)), color, 2)
            cv2.putText(frame, text, (int(x1), int(y1)-10),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)

def multi_level_lag_scheme(seq, lags=[1, 2, 3]):
    n = seq.shape[0]
    if n < max(lags):
        return seq
    lagged = [seq[n - lag - 1:n - lag] for lag in lags]
    return np.concatenate(lagged, axis=0)

def normalize_input(seq, scaler):
    num_features = scaler.mean_.shape[0]
    flat_seq = seq.reshape(-1, num_features)
    normalized = scaler.transform(flat_seq)
    return normalized.reshape(seq.shape)

def denormalize_output(pred, scaler):
    indices = [0, 1, 2, 3]
    pred_norm = pred[indices]
    mean = scaler.mean_[indices]
    scale = scaler.scale_[indices]
    return pred_norm * scale + mean

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































